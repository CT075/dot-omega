@article{rapoport2017,
author = {Rapoport, Marianna and Kabir, Ifaz and He, Paul and Lhot\'{a}k, Ond\v{r}ej},
title = {A Simple Soundness Proof for Dependent Object Types},
year = {2017},
issue_date = {October 2017},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {1},
number = {OOPSLA},
url = {https://doi.org/10.1145/3133870},
doi = {10.1145/3133870},
abstract = {Dependent Object Types (DOT) is intended to be a core calculus for modelling Scala. Its distinguishing feature is abstract type members, fields in objects that hold types rather than values. Proving soundness of DOT has been surprisingly challenging, and existing proofs are complicated, and reason about multiple concepts at the same time (e.g. types, values, evaluation). To serve as a core calculus for Scala, DOT should be easy to experiment with and extend, and therefore its soundness proof needs to be easy to modify. This paper presents a simple and modular proof strategy for reasoning in DOT. The strategy separates reasoning about types from other concerns. It is centred around a theorem that connects the full DOT type system to a restricted variant in which the challenges and paradoxes caused by abstract type members are eliminated. Almost all reasoning in the proof is done in the intuitive world of this restricted type system. Once we have the necessary results about types, we observe that the other aspects of DOT are mostly standard and can be incorporated into a soundness proof using familiar techniques known from other calculi.},
journal = {Proc. ACM Program. Lang.},
month = {oct},
articleno = {46},
numpages = {27},
keywords = {Scala, type safety, dependent object types, DOT calculus}
}
@inproceedings{amin2016,
  title={The Essence of Dependent Object Types},
  author={Nada Amin and Samuel Gr{\"u}tter and Martin Odersky and Tiark Rompf and Sandro Stucki},
  booktitle={A List of Successes That Can Change the World},
  year={2016}
}
@article{stucki2021,
author = {Stucki, Sandro and Giarrusso, Paolo G.},
title = {A Theory of Higher-Order Subtyping with Type Intervals},
year = {2021},
issue_date = {August 2021},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {5},
number = {ICFP},
url = {https://doi.org/10.1145/3473574},
doi = {10.1145/3473574},
abstract = {The calculus of Dependent Object Types (DOT) has enabled a more principled and robust implementation of Scala, but its support for type-level computation has proven insufficient. As a remedy, we propose F··ω, a rigorous theoretical foundation for Scala’s higher-kinded types. F··ω extends F&lt;:ω with interval kinds, which afford a unified treatment of important type- and kind-level abstraction mechanisms found in Scala, such as bounded quantification, bounded operator abstractions, translucent type definitions and first-class subtyping constraints. The result is a flexible and general theory of higher-order subtyping. We prove type and kind safety of F··ω, as well as weak normalization of types and undecidability of subtyping. All our proofs are mechanized in Agda using a fully syntactic approach based on hereditary substitution.},
journal = {Proc. ACM Program. Lang.},
month = {aug},
articleno = {69},
numpages = {30},
keywords = {type intervals, hereditary substitution, subtyping, bounded type operators, Scala, bounded polymorphism, singleton kinds, higher-kinded types, dependent kinds}
}
@inproceedings{stucki2017,
  title={Higher-Order Subtyping with Type Intervals},
  author={Sandro Stucki},
  year={2017}
}
@inproceedings{stoneharper2000,
author = {Stone, Christopher A. and Harper, Robert},
title = {Deciding Type Equivalence in a Language with Singleton Kinds},
year = {2000},
isbn = {1581131259},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/325694.325724},
doi = {10.1145/325694.325724},
abstract = {Work on the TILT compiler for Standard ML led us to study a language with singleton kinds: S(A) is the kind of all types provably equivalent to the type A. Singletons are interesting because they provide a very general form of definitions for type variables, allow fine-grained control of type computations, and allow many equational constraints to be expressed within the type system.Internally, TILT represents programs using a predicative variant of Girard's Fω enriched with singleton kinds, dependent product and function kinds (Σ and Π), and a sub-kinding relation. An important benefit of using a typed language as the representation of programs is that typechecking can detect many common compiler implementation errors. However, the decidability of typechecking for our particular representation is not obvious. In order to typecheck a term, we must be able to determine whether two type constructors are provably equivalent. But in the presence of singleton kinds, the equivalence of type constructors depends both on the typing context in which they are compared and on the kind at which they are compared.In this paper we concentrate on the key issue for decidability of typechecking: determining the equivalence of well-formed type constructors. We define the λΠΣS&lt; calculus, a model of the constructors and kinds of TILT's intermediate language. Inspired by Coquand's result for type theory, we prove decidability of constructor equivalence for λΠΣS≤ by exhibiting a novel — though slightly inefficient — type-directed comparison algorithm. The correctness of this algorithm is proved using an interesting variant of Kripke-style logical relations: unary relations are indexed by a single possible world (in our case, a typing context), but binary relations are indexed by two worlds. Using this result we can then show the correctness of a natural, practical algorithm used by the TILT compiler.},
booktitle = {Proceedings of the 27th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {214–227},
numpages = {14},
location = {Boston, MA, USA},
series = {POPL '00}
}
@InProceedings{wang2017,
  author =	{Fei Wang and Tiark Rompf},
  title =	{{Towards Strong Normalization for Dependent Object Types (DOT)}},
  booktitle =	{31st European Conference on Object-Oriented Programming (ECOOP 2017)},
  pages =	{27:1--27:25},
  series =	{Leibniz International Proceedings in Informatics (LIPIcs)},
  ISBN =	{978-3-95977-035-4},
  ISSN =	{1868-8969},
  year =	{2017},
  volume =	{74},
  editor =	{Peter M{\"u}ller},
  publisher =	{Schloss Dagstuhl--Leibniz-Zentrum fuer Informatik},
  address =	{Dagstuhl, Germany},
  URL =		{http://drops.dagstuhl.de/opus/volltexte/2017/7276},
  URN =		{urn:nbn:de:0030-drops-72763},
  doi =		{10.4230/LIPIcs.ECOOP.2017.27},
  annote =	{Keywords: Scala, DOT, strong normalization, logical relations, recursive types}
}
